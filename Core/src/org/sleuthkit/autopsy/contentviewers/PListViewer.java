/*
 * Autopsy Forensic Browser
 *
 * Copyright 2018 Basis Technology Corp.
 * Contact: carrier <at> sleuthkit <dot> org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.sleuthkit.autopsy.contentviewers;

import java.awt.Component;
import java.util.List;
import org.sleuthkit.datamodel.AbstractFile;
import java.util.Arrays;
import com.dd.plist.*;
import java.awt.BorderLayout;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Level;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.table.TableColumnModel;
import javax.xml.parsers.ParserConfigurationException;
import org.netbeans.swing.etable.ETableColumn;
import org.netbeans.swing.etable.ETableColumnModel;
import org.netbeans.swing.outline.DefaultOutlineModel;
import org.netbeans.swing.outline.Outline;
import org.openide.explorer.ExplorerManager;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.util.NbBundle;
import org.sleuthkit.autopsy.coreutils.Logger;
import org.sleuthkit.datamodel.TskCoreException;
import org.xml.sax.SAXException;


public class PListViewer extends javax.swing.JPanel implements FileTypeViewer, ExplorerManager.Provider {

    public static final String[] SUPPORTED_MIMETYPES = new String[]{"application/x-bplist"};
    private static final Logger LOGGER = Logger.getLogger(PListViewer.class.getName());
    
    private final org.openide.explorer.view.OutlineView outlineView;
    private final Outline outline;
    private ExplorerManager explorerManager;
    
    /**
     * Creates new form PListViewer
     */
    public PListViewer() {
       
        
        // Create an Outlineview and add to the panel
        outlineView = new org.openide.explorer.view.OutlineView();
        
        initComponents();
         
        //add(outlineView, BorderLayout.CENTER);
        
        outline = outlineView.getOutline();
        
        ((DefaultOutlineModel) outline.getOutlineModel()).setNodesColumnLabel("Key"); 
        
        Bundle.PListNode_KeyCol();
        outlineView.setPropertyColumns(
                //"Key", Bundle.PListNode_KeyCol(),
                "Type", Bundle.PListNode_TypeCol(),
                "Value", Bundle.PListNode_ValueCol());
         
        customize();
        
    }

    @NbBundle.Messages({"PListNode.KeyCol=Key",
    "PListNode.TypeCol=Type",
    "PListNode.ValueCol=Value" })
    
    
    private void customize() {
        
        //outlineView.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        //outlineView.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        
        outline.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
         
        outline.setRootVisible(false);
        if (null == explorerManager) {
           explorerManager = new ExplorerManager();
        }
        
        plistTableScrollPane.setViewportView(outlineView);
        
        //outline.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        
        this.setVisible(true);
        outline.setRowSelectionAllowed(false);
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        plistTableScrollPane = new javax.swing.JScrollPane();

        setLayout(new java.awt.BorderLayout());
        add(plistTableScrollPane, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public List<String> getSupportedMIMETypes() {
         return Arrays.asList(SUPPORTED_MIMETYPES);
    }

    @Override
    public void setFile(AbstractFile file) {
        processPlist(file);
    }

    @Override
    public Component getComponent() {
       return this;
    }

    @Override
    public void resetComponent() {
        // RAMAN TBD
       
    }

    
    /**
     * Process the given Plist file
     *
     * @param plistFile -
     *
     * @return none
     */
    private void processPlist(AbstractFile plistFile) {
       
        byte[] buf = new byte[(int) plistFile.getSize()];
        try {
            final int bytesRead = plistFile.read(buf, 0, plistFile.getSize());
        } catch (TskCoreException ex) {
            LOGGER.log(Level.SEVERE, "Error reading bytes of plist file.", ex);
        }

        List<PropKeyValue> plist = parsePList(buf);
        
        setupTable(plist);
    }
    
    
     /**
     * Sets up the columns in the display table
     *
     * @param tableRows
     */
    void setupTable(List<PropKeyValue> tableRows) {

        explorerManager.setRootContext(new AbstractNode(Children.create(new PListRowFactory(tableRows), true)));
    }
    
    
   
    private PropKeyValue parseProperty(String key, NSObject value) {
        if (value == null) {
            return null;
        } else if (value instanceof NSString) {
            return new PropKeyValue(key, "String", value.toString());
        } else if (value instanceof NSNumber) {
            NSNumber number = (NSNumber) value;
            if (number.isInteger()) {
                return new PropKeyValue(key, "Number",  new Long(number.longValue()) );
            } else if (number.isBoolean()) {
                return new PropKeyValue(key, "Boolean",  new Boolean(number.boolValue()) );
            } else {
                return new PropKeyValue(key, "Number",  new Float(number.floatValue())) ;
            }
        } else if (value instanceof NSArray) {
            List<PropKeyValue> children = new ArrayList<>();
            NSArray array = (NSArray) value;
            
            PropKeyValue pkv = new PropKeyValue(key, "Array", array);
            for (int i = 0; i < array.count(); i++) {
                children.add(parseProperty("", array.objectAtIndex(i)));
            }
            
            pkv.setChildren(children.toArray(new PropKeyValue[0] ));
            return pkv;
        } else if (value instanceof NSDictionary) {
            List<PropKeyValue> children = new ArrayList<>();
            NSDictionary dict = (NSDictionary) value;
            
            PropKeyValue pkv = new PropKeyValue(key, "Dictionary", dict);
            for (String key2 : ((NSDictionary) value).allKeys()) {
                NSObject o = ((NSDictionary) value).objectForKey(key2);
                children.add(parseProperty(key2, o));
            }
            
            pkv.setChildren(children.toArray(new PropKeyValue[0] ));
            return pkv;
        } else {
            LOGGER.severe("Can't cast from " + value.getClass());
        }
        
        return null;
    }
    
    private List<PropKeyValue> parsePList(byte[] plistbytes) {

        List<PropKeyValue> plist = new ArrayList<>();

        try {
            NSDictionary rootDict = (NSDictionary) PropertyListParser.parse(plistbytes);

            String[] keys = rootDict.allKeys();
            for (int i = 0; i < keys.length; i++) {

                NSObject object = rootDict.objectForKey(keys[i]);
                
                System.out.println("");       
                System.out.println("Found Key = " + keys[i]);
                System.out.println("Value class = " + object.getClass().toString());
                   
                PropKeyValue pkv = parseProperty(keys[i], rootDict.objectForKey(keys[i]));
                if (null != pkv) { 
                    plist.add(pkv);
                }   
            }
        } catch (PropertyListFormatException | IOException | ParseException | ParserConfigurationException | SAXException ex) {
            LOGGER.log(Level.SEVERE, "Failed to parse PList.", ex);
            return null;
        }

        return plist;
    }

    @Override
    public ExplorerManager getExplorerManager() {
        
        return explorerManager;
    }
    
    
    class PropKeyValue {
   
        // RAMAN TBD: define an enmum for type??
        
        
        private final String key;
        private final String type;
        private final Object value;

        private PropKeyValue[] children;
        
        PropKeyValue(String key, String type, Object value) {
            this.key = key;
            this.type = type;
            this.value = value;
            
            this.children = null;
        }
        
        String getKey() {
            return this.key;
        }
        String getType() {
            return this.type;
        }
        
        Object getValue() {
            return this.value;
        }
        
        public PropKeyValue[] getChildren() {
            return children;
        }
        
        public void setChildren(PropKeyValue...children) {
            this.children = children;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane plistTableScrollPane;
    // End of variables declaration//GEN-END:variables
}
