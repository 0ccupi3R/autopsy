/*
 * Sample module in the public domain.  Feel free to use this as a template
 * for your modules.
 * 
 *  Contact: Brian Carrier [carrier <at> sleuthkit [dot] org]
 *
 *  This is free and unencumbered software released into the public domain.
 *  
 *  Anyone is free to copy, modify, publish, use, compile, sell, or
 *  distribute this software, either in source code form or as a compiled
 *  binary, for any purpose, commercial or non-commercial, and by any
 *  means.
 *  
 *  In jurisdictions that recognize copyright laws, the author or authors
 *  of this software dedicate any and all copyright interest in the
 *  software to the public domain. We make this dedication for the benefit
 *  of the public at large and to the detriment of our heirs and
 *  successors. We intend this dedication to be an overt act of
 *  relinquishment in perpetuity of all present and future rights to this
 *  software under copyright law.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *  OTHER DEALINGS IN THE SOFTWARE. 
 */
package org.sleuthkit.autopsy.examples;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.sleuthkit.autopsy.casemodule.Case;
import org.sleuthkit.autopsy.coreutils.Logger;
import org.sleuthkit.autopsy.externalresults.ExternalResultsImporter;
import org.sleuthkit.autopsy.externalresults.ExternalResultsXML;
import org.sleuthkit.autopsy.ingest.DataSourceIngestModule;
import org.sleuthkit.autopsy.ingest.DataSourceIngestModuleProgress;
import org.sleuthkit.autopsy.ingest.IngestJobContext;
import org.sleuthkit.autopsy.ingest.IngestModuleReferenceCounter;
import org.sleuthkit.autopsy.ingest.IngestServices;
import org.sleuthkit.datamodel.BlackboardArtifact;
import org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;
import org.sleuthkit.datamodel.BlackboardAttribute;
import org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;
import org.sleuthkit.datamodel.Content;
import org.sleuthkit.datamodel.TskCoreException;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * Sample data source ingest module that doesn't do much. Demonstrates use of
 * utility classes: ExecUtils and the org.sleuthkit.autopsy.externalresults
 * package.
 */
public class SampleExecutableDataSourceIngestModule implements DataSourceIngestModule {

    private static final String RESULTS_FILE_NAME = "results.xml";
    private static final IngestModuleReferenceCounter refCounter = new IngestModuleReferenceCounter();
    private static final String moduleName = SampleExecutableIngestModuleFactory.getModuleName();
    private long jobId;
    private String outputDirPath;

    @Override
    public void startUp(IngestJobContext context) throws IngestModuleException {
        jobId = context.getJobId();
        if (refCounter.incrementAndGet(jobId) == 1) {
            // Create an output directory for this job.
            outputDirPath = Case.getCurrentCase().getModulesOutputDirAbsPath() + File.separator + moduleName; //NON-NLS
            File outputDir = new File(outputDirPath);
            if (outputDir.exists() == false) {
                outputDir.mkdirs();
            }
        }
    }

    @Override
    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {
        if (refCounter.get(jobId) == 1) {
            try {
                // There will be two tasks: data source analysis and import of 
                // the results of the analysis.
                progressBar.switchToDeterminate(2);

                // Do the analysis. The following commented out code could be 
                // used to run an executable. In this case the executable takes 
                // two command line arguments, the path to the data source to be 
                // analyzed and the path to a results file. The results file is 
                // an XML file (see org.sleuthkit.autopsy.externalresults.autopsy_external_results.xsd)
                // with instructions for the import of blackboard artifacts, 
                // derived files, and reports generated by the analysis. In this 
                // sample ingest module, the generation of the analysis results is
                // simulated. 
                String dataSourcePath = dataSource.getImage().getPaths()[0];
                String resultsFilePath = outputDirPath + File.separator + RESULTS_FILE_NAME + jobId;
//                ExecUtil executor = new ExecUtil();
//                executor.execute("some.exe", dataSourcePath, resultsFilePath);
                generateSimulatedResults(dataSourcePath, resultsFilePath);
                progressBar.progress(1);

                // Import the results of the analysis.
                ExternalResultsImporter.importResultsFromXML(dataSource, resultsFilePath);
                progressBar.progress(2);
            } catch (TskCoreException | ParserConfigurationException | IOException ex) {
                Logger logger = IngestServices.getInstance().getLogger(moduleName);
                logger.log(Level.SEVERE, "Failed to simulate analysis and results import", ex);  //NON-NLS
                return ProcessResult.ERROR;
            }
        }

        return ProcessResult.OK;
    }

    private void generateSimulatedResults(String dataSourcePath, String resultsFilePath) throws ParserConfigurationException, IOException {
        generateSimulatedResultsFile(dataSourcePath, generateSimulatedDerivedFiles(), generateSimulatedReport(), resultsFilePath);
    }

    private List<String> generateSimulatedDerivedFiles() throws IOException {
        List<String> filePaths = new ArrayList<>();
        String fileContents = "This is a simulated derived file.";
        for (int i = 0; i < 3; ++i) {
            String fileName = "report" + jobId + "_" + i + ".txt";
            generateFile(fileName, fileContents.getBytes());
            filePaths.add(outputDirPath + File.separator + fileName);
        }
        return filePaths;
    }

    private String generateSimulatedReport() throws IOException {
        String reportFileName = "report" + jobId + ".txt";
        String reportContents = "This is a simulated report.";
        generateFile(reportFileName, reportContents.getBytes());
        return outputDirPath + File.separator + reportFileName;
    }

    private void generateFile(String fileName, byte[] fileContents) throws IOException {
        String filePath = outputDirPath + File.separator + fileName;
        File file = new File(filePath);
        if (!file.exists()) {
            file.createNewFile();
        }
        try (FileOutputStream fileStream = new FileOutputStream(file)) {
            fileStream.write(fileContents);
            fileStream.flush();
        }
    }

    private void generateSimulatedResultsFile(String dataSourcePath, List<String> derivedFilePaths, String reportPath, String resultsFilePath) throws ParserConfigurationException {
        // Create the XML DOM document and the root element.
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        Document doc = docBuilder.newDocument();
        Element rootElement = doc.createElement(ExternalResultsXML.ROOT_ELEM.toString());
        doc.appendChild(rootElement);

        // Add a data source element to the root element. This is optional and 
        // is currently ignored by Autopsy, but it is used here to provide some 
        // portable context to the results file.
        Element dataSourceElement = doc.createElement(ExternalResultsXML.DATA_SRC_ELEM.toString());
        dataSourceElement.setTextContent(dataSourcePath);
        rootElement.appendChild(dataSourceElement);

        // Add an artifacts list element to the root element.
        Element artifactsListElement = doc.createElement(ExternalResultsXML.ARTIFACTS_LIST_ELEM.toString());

        // Add an artifact element to the artifacts list element. A standard 
        // artifact type is used as the required type attribute of the element.
        Element artifactElement = doc.createElement(ExternalResultsXML.ARTIFACT_ELEM.toString());
        artifactElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getLabel());
        
        // Add a file element to the artifact element, and a path element to the 
        // file element. This is how a source file for an artifact is specified.
        Element fileElement = doc.createElement(ExternalResultsXML.FILE_ELEM.toString());
        Element pathElement = doc.createElement(ExternalResultsXML.PATH_ELEM.toString());
        pathElement.setTextContent(dataSourcePath);
        fileElement.appendChild(pathElement);
        artifactElement.appendChild(fileElement);
        
        // Add an attribute element to the artifact element. A standard attribute
        // type is used as the required type attribute of the artifact attribute.
        // A value element is added to the attribute, using the default type
        // attribute of ExternalXML.VALUE_TYPE_TEXT.
        Element attributeElement = doc.createElement(ExternalResultsXML.ATTRIBUTE_ELEM.toString());
        attributeElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), ATTRIBUTE_TYPE.TSK_SET_NAME.getLabel());
        Element attributeValueElement = doc.createElement(ExternalResultsXML.VALUE_ELEM.toString());
        attributeValueElement.setTextContent("SampleInterestingFilesSet");
        artifactElement.appendChild(attributeElement);
        artifactsListElement.appendChild(artifactElement);
        
        // Add an artifact with a user-defined type that has an attribute with
        // a user-defined type. No file element is added to the artifact element,
        // so the data source will be used as the default for the source file.
        artifactElement = doc.createElement(ExternalResultsXML.ARTIFACT_ELEM.toString());
        artifactElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), "SampleExecutableDataIngestModuleArtifact");
        attributeElement = doc.createElement(ExternalResultsXML.ATTRIBUTE_ELEM.toString());
        attributeElement.setAttribute(ExternalResultsXML.TYPE_ATTR.toString(), "SampleExecutableDataIngestModuleAttribute");
        artifactElement.appendChild(attributeElement);
        artifactsListElement.appendChild(artifactElement);
    }
}
