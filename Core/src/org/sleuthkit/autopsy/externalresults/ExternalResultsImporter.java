/*
 * Autopsy Forensic Browser
 *
 * Copyright 2014 Basis Technology Corp.
 * Contact: carrier <at> sleuthkit <dot> org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this localFile except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.sleuthkit.autopsy.externalresults;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import org.sleuthkit.autopsy.casemodule.Case;
import org.sleuthkit.autopsy.casemodule.services.FileManager;
import org.sleuthkit.autopsy.coreutils.ErrorInfo;
import org.sleuthkit.autopsy.coreutils.Logger;
import org.sleuthkit.autopsy.ingest.IngestServices;
import org.sleuthkit.autopsy.ingest.ModuleContentEvent;
import org.sleuthkit.autopsy.ingest.ModuleDataEvent;
import org.sleuthkit.datamodel.AbstractFile;
import org.sleuthkit.datamodel.BlackboardArtifact;
import org.sleuthkit.datamodel.BlackboardAttribute;
import org.sleuthkit.datamodel.Content;
import org.sleuthkit.datamodel.DerivedFile;
import org.sleuthkit.datamodel.SleuthkitCase;
import org.sleuthkit.datamodel.TskCoreException;

/**
 * Uses a standard representation of results data (e.g., artifacts, derived
 * files, reports) to import results generated by a process external to Autopsy
 * into Autopsy.
 */
public final class ExternalResultsImporter {

    private static final Logger logger = Logger.getLogger(ExternalResultsImporter.class.getName());
    private final List<ErrorInfo> errors = new ArrayList<>();

    /**
     * Import results generated by a process external to Autopsy into Autopsy.
     *
     * @param results A standard representation of results data (e.g.,
     * artifacts, derived files, reports)from the data source.
     * @return A collection of error messages, possibly empty. The error
     * messages are already logged but are provided to allow the caller to
     * provide additional user feedback via the Autopsy user interface.
     */
    public List<ErrorInfo> importResults(ExternalResults results) {
        // Import files first, they may be artifactData sources.
        importDerivedFiles(results);
        importArtifacts(results);
        importReports(results);
        return Collections.unmodifiableList(this.errors);
    }

    private void importDerivedFiles(ExternalResults results) {
        FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();
        for (ExternalResults.DerivedFile fileData : results.getDerivedFiles()) {
            String filePath = Case.getCurrentCase().getCaseDirectory() + File.separator + fileData.getLocalPath();
            try {
                File localFile = new File(filePath);
                if (!localFile.exists()) {
                    AbstractFile parentFile = findFile(results.getDataSource(), fileData.getParentPath());
                    if (parentFile != null) {
                        DerivedFile derivedFile = fileManager.addDerivedFile(localFile.getName(), fileData.getLocalPath(), localFile.length(),
                                0, 0, 0, 0, // Do not currently have file times for derived files from external processes.
                                true, parentFile,
                                "", "", "", ""); // Not currently providing derivation info for derived files from external processes.
                        IngestServices.getInstance().fireModuleContentEvent(new ModuleContentEvent(derivedFile));
                    } else {
                        String errorMessage = String.format("Could not import derived file at %s, parent file %s not found", filePath);
                        ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);
                        this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));
                    }
                } else {
                    String errorMessage = String.format("Could not import derived file at %s, file does not exist", filePath);
                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);
                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));
                }
            } catch (TskCoreException ex) {
                String errorMessage = String.format("Could not import derived file at %s, error querying/updating case database", filePath);
                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);
                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));
            }
        }
    }

    private void importArtifacts(ExternalResults results) {
        SleuthkitCase caseDb = Case.getCurrentCase().getSleuthkitCase();
        for (ExternalResults.Artifact artifactData : results.getArtifacts()) {
            try {
                // Add the artifact to the case database.
                boolean artifactTypeIsUserDefined = false;
                int artifactTypeId = caseDb.getArtifactTypeIdIfExists(artifactData.getType());
                if (artifactTypeId == -1) {
                    artifactTypeId = caseDb.addArtifactType(artifactData.getType(), artifactData.getType());
                    artifactTypeIsUserDefined = true;
                }
                Content sourceFile = findFile(results.getDataSource(), artifactData.getSourceFilePath());
                BlackboardArtifact artifact = sourceFile.newArtifact(artifactTypeId);

                // Add the artifact's attributes to the case database.
                Collection<BlackboardAttribute> attributes = new ArrayList<>();
                for (ExternalResults.ArtifactAttribute attributeData : artifactData.getAttributes()) {
                    int attributeTypeId = caseDb.getAttrTypeIdIfExists(attributeData.getType());
                    if (artifactTypeId == -1) {
                        artifactTypeId = caseDb.addArtifactType(attributeData.getType(), attributeData.getType());
                    }
                    switch (attributeData.getValueType()) {
                        case "text": //NON-NLS
                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), attributeData.getValue()));
                            break;
                        case "int32": //NON-NLS
                            int intValue = Integer.parseInt(attributeData.getValue());
                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), intValue));
                            break;
                        case "int64": //NON-NLS
                            long longValue = Long.parseLong(attributeData.getValue());
                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), longValue));
                            break;
                        case "double": //NON-NLS
                            double doubleValue = Double.parseDouble(attributeData.getValue());
                            attributes.add(new BlackboardAttribute(attributeTypeId, attributeData.getSourceModule(), doubleValue));
                            break;
                        default:
                            String errorMessage = String.format("Could not import %s attribute, value = %s, for %s artifact from %s, unrecognized attribute value type: %s", 
                                    attributeData.getType(), attributeData.getValue(), 
                                    artifactData.getType(), artifactData.getSourceFilePath(),
                                    attributeData.getValueType());
                            ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);
                            this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));
                            break;
                    }
                }
                artifact.addAttributes(attributes);

                if (!artifactTypeIsUserDefined) {
                    IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(this.getClass().getSimpleName(), BlackboardArtifact.ARTIFACT_TYPE.fromID(artifactTypeId)));
                }
            } catch (TskCoreException ex) {
                String errorMessage = String.format("Could not import %s artifact from %s, error updating case database", artifactData.getType(), artifactData.getSourceFilePath());
                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);
                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));
            }
        }
    }

    private void importReports(ExternalResults results) {
        for (ExternalResults.Report report : results.getReports()) {
            String reportPath = Case.getCurrentCase().getCaseDirectory() + File.separator + report.getLocalPath();
            try {
                File reportFile = new File(reportPath);
                if (reportFile.exists()) {
                    Case.getCurrentCase().getSleuthkitCase().addReport(reportPath, report.getDisplayName());
                } else {
                    String errorMessage = String.format("Could not import report at %s, file does not exist", reportPath);
                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);
                    this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage));
                }
            } catch (TskCoreException ex) {
                String errorMessage = String.format("Could not import report at %s, error updating case database", reportPath);
                ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage, ex);
                this.errors.add(new ErrorInfo(ExternalResultsImporter.class.getName(), errorMessage, ex));
            }
        }
    }

    private AbstractFile findFile(Content dataSource, String filePath) throws TskCoreException {
        AbstractFile file = null;
        Path path = Paths.get(filePath);
        if (path.isAbsolute()) {
            FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();
            List<AbstractFile> files = fileManager.openFiles(dataSource, filePath);
            if (files.size() > 0) {
                file = files.get(0);
                if (files.size() > 1) {
                    String errorMessage = String.format("Ambiguous file path: %s", filePath);
                    ExternalResultsImporter.logger.log(Level.SEVERE, errorMessage);
                    this.errors.add(new ErrorInfo(this.getClass().getName(), errorMessage));
                }
            }
        } else {
            // RJCTODO: Need a look up that goes for relative path            
        }
        return file;
    }
}
