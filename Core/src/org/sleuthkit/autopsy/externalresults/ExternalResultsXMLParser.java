/*
 * Autopsy Forensic Browser
 *
 * Copyright 2014 Basis Technology Corp.
 * Contact: carrier <at> sleuthkit <dot> org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.sleuthkit.autopsy.externalresults;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.sleuthkit.autopsy.coreutils.ErrorInfo;
import org.sleuthkit.autopsy.coreutils.XMLUtil;
import org.sleuthkit.datamodel.Content;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

/**
 * Parses an XML representation of of results data (e.g., artifacts, derived
 * files, reports) generated by a process external to Autopsy into Autopsy.
 */
public final class ExternalResultsXMLParser implements ExternalResultsParser {

    private static final Logger logger = Logger.getLogger(ExternalResultsXMLParser.class.getName());
    private static final String XSD_FILE = "autopsy_external_results.xsd"; //NON-NLS
    private final String resultsFilePath;
    private final ExternalResults externalResults;
    private final List<ErrorInfo> errors = new ArrayList<>();

    /**
     * Tags for an external results XML file.
     */
    public enum TagNames {

        ROOT_ELEM("autopsy_results"), //NON-NLS
        ARTIFACTS_LIST_ELEM("artifacts"), //NON-NLS
        ARTIFACT_ELEM("artifact"), //NON-NLS
        SOURCE_FILE_ELEM("source_file"), //NON-NLS
        PATH_ELEM("path"), //NON-NLS
        ATTRIBUTE_ELEM("attribute"), //NON-NLS
        VALUE_ELEM("value"), //NON-NLS
        SOURCE_MODULE_ELEM("source_module"), //NON-NLS
        REPORTS_LIST_ELEM("reports"), //NON-NLS
        REPORT_ELEM("report"), //NON-NLS
        DISPLAY_NAME_ELEM("display_name"), //NON-NLS
        LOCAL_PATH_ELEM("local_path"), //NON-NLS
        DERIVED_FILES_LIST_ELEM("derived_files"), //NON-NLS
        DERIVED_FILE_ELEM("derived_file"), //NON-NLS
        PARENT_PATH_ELEM("parent_path"), //NON-NLS
        TYPE_ATTR("type"), //NON-NLS
        NAME_ATTR("name"), //NON-NLS 
        VALUE_TYPE_TEXT("text"),
        VALUE_TYPE_INT32("int32"),
        VALUE_TYPE_INT64("int64"),
        VALUE_TYPE_DOUBLE("double");
        private final String text;

        private TagNames(final String text) {
            this.text = text;
        }

        @Override
        public String toString() {
            return text;
        }
    }

    /**
     * Constructor.
     *
     * @param importFilePath Full path of the results file to be parsed.
     */
    public ExternalResultsXMLParser(Content dataSource, String resultsFilePath) {
        this.resultsFilePath = resultsFilePath;
        externalResults = new ExternalResults(dataSource);
    }

    @Override
    public ExternalResults parse() {
        try {
            // Note that XMLUtil.loadDoc() logs a warning if the file does not
            // conform to the XSD, but still returns a Document object. Until 
            // this behavior is improved, validation is still required. If 
            // XMLUtil.loadDoc() does return null, it failed to load the 
            // document and it logged the error.
            final Document doc = XMLUtil.loadDoc(ExternalResultsXMLParser.class, this.resultsFilePath, XSD_FILE);
            if (doc != null) {
                final Element rootElem = doc.getDocumentElement();
                if (rootElem != null && rootElem.getNodeName().equals(TagNames.ROOT_ELEM.toString())) {
                    parseDerivedFiles(rootElem);
                    parseArtifacts(rootElem);
                    parseReports(rootElem);
                } else {
                    String errorMessage = String.format("Did not find %s root element of %s", TagNames.ROOT_ELEM.toString(), this.resultsFilePath);
                    recordError(errorMessage);
                }
            }
        } catch (Exception ex) {
            String errorMessage = String.format("Error parsing %s", this.resultsFilePath);
            recordError(errorMessage, ex);
        }
        return externalResults;
    }

    @Override
    public List<ErrorInfo> getErrorInfo() {
        return Collections.unmodifiableList(this.errors);
    }

    private void parseDerivedFiles(Element rootElement) {
        NodeList derivedFilesListNodes = rootElement.getElementsByTagName(TagNames.DERIVED_FILES_LIST_ELEM.toString());
        for (int i = 0; i < derivedFilesListNodes.getLength(); ++i) {
            Element derivedFilesListElem = (Element) derivedFilesListNodes.item(i);
            NodeList derivedFileNodes = derivedFilesListElem.getElementsByTagName(TagNames.DERIVED_FILE_ELEM.toString());
            for (int j = 0; j < derivedFileNodes.getLength(); ++j) {
                Element derivedFileElem = (Element) derivedFileNodes.item(j);
                String path = getChildElementContent(derivedFileElem, TagNames.LOCAL_PATH_ELEM.toString());
                if (path.isEmpty()) {
                    continue;
                }
                String parentPath = getChildElementContent((Element) derivedFileNodes.item(j), TagNames.PARENT_PATH_ELEM.toString());
                if (parentPath.isEmpty()) {
                    continue;
                }
                externalResults.addDerivedFile(path, parentPath);
            }
        }
    }

    private void parseArtifacts(final Element root) {
        NodeList artifactsListNodes = root.getElementsByTagName(TagNames.ARTIFACTS_LIST_ELEM.toString());
        for (int i = 0; i < artifactsListNodes.getLength(); ++i) {
            Element artifactsListElem = (Element) artifactsListNodes.item(i);
            NodeList artifactNodes = artifactsListElem.getElementsByTagName(TagNames.ARTIFACT_ELEM.toString());
            for (int j = 0; j < artifactNodes.getLength(); ++j) {
                Element artifactElem = (Element) artifactNodes.item(j);
                final String type = getElementAttributeValue(artifactElem, TagNames.TYPE_ATTR.toString());
                if (!type.isEmpty()) {
                    final String sourceFilePath = this.getChildElementContent((Element) artifactElem, TagNames.PATH_ELEM.toString());
                    if (!sourceFilePath.isEmpty()) {
                        ExternalResults.Artifact artifact = externalResults.addArtifact(type, sourceFilePath);
                        parseArtifactAttributes(artifactElem, artifact);
                    }
                }
            }
        }
    }

    private void parseArtifactAttributes(final Element artifactElem, ExternalResults.Artifact artifact) {
        NodeList attributeNodesList = artifactElem.getElementsByTagName(TagNames.ATTRIBUTE_ELEM.toString());
        for (int i = 0; i < attributeNodesList.getLength(); ++i) {
            // Get the type of the artifact attribute.
            Element attributeElem = (Element) attributeNodesList.item(i);
            final String type = getElementAttributeValue(attributeElem, TagNames.TYPE_ATTR.toString());
            if (type.isEmpty()) {
                continue;
            }
            // Get the value of the artifact attribute.
            Element valueElem = this.getChildElement(attributeElem, TagNames.VALUE_ELEM.toString());
            if (valueElem == null) {
                continue;
            }
            final String value = valueElem.getTextContent();
            if (value.isEmpty()) {
                String errorMessage = String.format("Found %s element that has no content in %s",
                        TagNames.VALUE_ELEM.toString(), this.resultsFilePath);
                recordError(errorMessage);
                continue;
            }
            // Get the value type.
            String valueType = valueElem.getAttribute(TagNames.TYPE_ATTR.toString());
            if (valueType.isEmpty()) {
                valueType = TagNames.VALUE_TYPE_TEXT.toString();
            }
            // Get the source module for the artifact attribute.
            String sourceModule = "";
            NodeList sourceModuleNodes = attributeElem.getElementsByTagName(TagNames.SOURCE_MODULE_ELEM.toString());
            if (sourceModuleNodes.getLength() > 0) {
                if (sourceModuleNodes.getLength() > 1) {
                    String errorMessage = String.format("Found multiple %s child elements for %s element in %s, ignoring all but first occurrence",
                            TagNames.SOURCE_MODULE_ELEM.toString(), attributeElem.getTagName(), this.resultsFilePath);
                    recordError(errorMessage);
                }
                Element srcModuleElem = (Element) sourceModuleNodes.item(0);
                sourceModule = srcModuleElem.getTextContent();
            }
            // Add the attribute to the artifact.
            artifact.addAttribute(type, value, valueType, sourceModule);
        }
    }

    private void parseReports(Element root) {
        NodeList reportsListNodes = root.getElementsByTagName(TagNames.REPORTS_LIST_ELEM.toString());
        for (int i = 0; i < reportsListNodes.getLength(); ++i) {
            Element reportsListElem = (Element) reportsListNodes.item(i);
            NodeList reportNodes = reportsListElem.getElementsByTagName(TagNames.REPORT_ELEM.toString());
            for (int j = 0; j < reportNodes.getLength(); ++j) {
                Element reportElem = (Element) reportNodes.item(j);
                String displayName = getChildElementContent(reportElem, TagNames.DISPLAY_NAME_ELEM.toString());
                if (displayName.isEmpty()) {
                    continue;
                }
                String path = getChildElementContent(reportElem, TagNames.LOCAL_PATH_ELEM.toString());
                if (displayName.isEmpty()) {
                    continue;
                }
                externalResults.addReport(displayName, path);
            }
        }
    }

    private Element getChildElement(Element parentElement, String childElementTagName) {
        Element childElem = null;
        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);
        if (childNodes.getLength() > 0) {
            if (childNodes.getLength() > 1) {
                logger.log(Level.SEVERE, "Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence", new Object[]{
                    childElementTagName,
                    parentElement.getTagName(),
                    this.resultsFilePath}); // NON-NLS
            }
        }
        return childElem;
    }

    private String getElementAttributeValue(Element element, String attributeName) {
        final String attributeValue = element.getAttribute(attributeName);
        if (attributeValue.isEmpty()) {
            logger.log(Level.SEVERE, "Found {0} element missing {1} attribute in {2}", new Object[]{
                element.getTagName(),
                attributeName,
                this.resultsFilePath});
        }
        return attributeValue;
    }

    private String getChildElementContent(Element parentElement, String childElementTagName) {
        String content = "";
        NodeList childNodes = parentElement.getElementsByTagName(childElementTagName);
        if (childNodes.getLength() > 0) {
            if (childNodes.getLength() > 1) {
                logger.log(Level.SEVERE, "Found multiple {0} child elements for {1} element in {2}, ignoring all but first occurrence", new Object[]{
                    childElementTagName,
                    parentElement.getTagName(),
                    this.resultsFilePath}); // NON-NLS
            }
            Element childElement = (Element) childNodes.item(0);
            content = childElement.getTextContent();
            if (content.isEmpty()) {
                logger.log(Level.SEVERE, "Found {0} element with {1} child element that has no content in {2}", new Object[]{
                    parentElement.getTagName(),
                    childElementTagName,
                    this.resultsFilePath}); // NON-NLS
            }
        } else {
            logger.log(Level.SEVERE, "Found {0} element missing {1} child element in {2}", new Object[]{
                parentElement.getTagName(),
                childElementTagName,
                this.resultsFilePath});  // NON-NLS   
        }
        return content;
    }

    private void recordError(String errorMessage) {
        this.logger.log(Level.SEVERE, errorMessage);
        this.errors.add(new ErrorInfo(this.getClass().getSimpleName(), errorMessage));
    }

    private void recordError(String errorMessage, Exception ex) {
        this.logger.log(Level.SEVERE, errorMessage, ex);
        this.errors.add(new ErrorInfo(this.getClass().getSimpleName(), errorMessage, ex));
    }
}
