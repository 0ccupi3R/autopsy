/*
 * Autopsy Forensic Browser
 * 
 * Copyright 2011 Basis Technology Corp.
 * Contact: carrier <at> sleuthkit <dot> org
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * KeywordSearchListImportExportForm.java
 *
 * Created on Feb 10, 2012, 4:04:13 PM
 */
package org.sleuthkit.autopsy.keywordsearch;

import java.awt.Component;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;

/**
 *
 * @author dfickling
 */
public class KeywordSearchListsManagementPanel extends javax.swing.JPanel {

    private Logger logger = Logger.getLogger(KeywordSearchListsManagementPanel.class.getName());
    private KeywordListTableModel tableModel;
    
    private static KeywordSearchListsManagementPanel instance = null;
    
    /** Creates new form KeywordSearchListImportExportForm */
    public KeywordSearchListsManagementPanel() {
        tableModel = new KeywordListTableModel();
        initComponents();
        customizeComponents();
    }
    
    public static synchronized KeywordSearchListsManagementPanel getDefault() {
        if (instance == null) {
            instance = new KeywordSearchListsManagementPanel();
        }
        return instance;
    }
    
    private void customizeComponents() {


        listsTable.setAutoscrolls(true);
        //listsTable.setTableHeader(null);
        listsTable.setShowHorizontalLines(false);
        listsTable.setShowVerticalLines(false);

        listsTable.getParent().setBackground(listsTable.getBackground());

        //customize column witdhs
        listsTable.setSize(260, 200);
        final int width = listsTable.getSize().width;
        TableColumn column = null;
        for (int i = 0; i < 2; i++) {
            column = listsTable.getColumnModel().getColumn(i);
            switch (i) {
                case 0:
                    column.setPreferredWidth(((int) (width * 0.69)));
                    break;
                case 1:
                    column.setPreferredWidth(((int) (width * 0.30)));
                    break;
                default:
                    break;

            }

        }
        listsTable.setCellSelectionEnabled(false);
        listsTable.setRowSelectionAllowed(true);
        tableModel.resync();

        KeywordSearchListsXML.getCurrent().addPropertyChangeListener(new PropertyChangeListener() {

            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                if (evt.getPropertyName().equals(KeywordSearchListsXML.ListsEvt.LIST_ADDED.toString())) {
                    tableModel.resync();
                    for(int i = 0; i<listsTable.getRowCount(); i++){
                            String name = (String) listsTable.getValueAt(i, 0);
                            if(((String) evt.getNewValue()).equals(name))
                                listsTable.getSelectionModel().setSelectionInterval(i, i);
                    }
                } else if (evt.getPropertyName().equals(KeywordSearchListsXML.ListsEvt.LIST_DELETED.toString())) {
                    tableModel.resync();
                    if(listsTable.getRowCount() > 0)
                        listsTable.getSelectionModel().setSelectionInterval(0, 0);
                } else if (evt.getPropertyName().equals(KeywordSearchListsXML.ListsEvt.LIST_UPDATED.toString())) {
                    tableModel.resync((String) evt.getNewValue()); //changed list name
                }
            }
        });

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        listsTable = new javax.swing.JTable();
        searchListsLabel = new javax.swing.JLabel();
        newListButton = new javax.swing.JButton();

        listsTable.setModel(tableModel);
        listsTable.setShowHorizontalLines(false);
        listsTable.setShowVerticalLines(false);
        listsTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(listsTable);

        searchListsLabel.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        searchListsLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchListsManagementPanel.class, "KeywordSearchListsManagementPanel.searchListsLabel.text")); // NOI18N

        newListButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchListsManagementPanel.class, "KeywordSearchListsManagementPanel.newListButton.text")); // NOI18N
        newListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newListButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(searchListsLabel)
                .addContainerGap(113, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(newListButton)
                .addContainerGap(209, Short.MAX_VALUE))
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 292, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(searchListsLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 223, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(newListButton)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void newListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newListButtonActionPerformed
        KeywordSearchListsXML writer = KeywordSearchListsXML.getCurrent();
        String listName = (String) JOptionPane.showInputDialog(null, "New keyword list name:", "New Keyword List", JOptionPane.PLAIN_MESSAGE, null, null, "");
        if (listName == null || listName.trim().equals("")) {
            return;
        }
        boolean shouldAdd = false;
        if (writer.listExists(listName)) {
            boolean replace = KeywordSearchUtil.displayConfirmDialog("New Keyword List", "Keyword List <" + listName + "> already exists, do you want to replace it?", KeywordSearchUtil.DIALOG_MESSAGE_TYPE.WARN);
            if (replace) {
                shouldAdd = true;
            }
        } else {
            shouldAdd = true;
        }
        if (shouldAdd) {
            writer.addList(listName, new ArrayList<Keyword>());
        }
        for (int i = 0; i < listsTable.getRowCount(); i++) {
            if (listsTable.getValueAt(i, 0).equals(listName)) {
                listsTable.getSelectionModel().addSelectionInterval(i, i);
            }
        }
    }//GEN-LAST:event_newListButtonActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable listsTable;
    private javax.swing.JButton newListButton;
    private javax.swing.JLabel searchListsLabel;
    // End of variables declaration//GEN-END:variables

    
    private class KeywordListTableModel extends AbstractTableModel {
        //data

        private KeywordSearchListsXML listsHandle = KeywordSearchListsXML.getCurrent();
        private Set<TableEntry> listData = new TreeSet<TableEntry>();

        @Override
        public int getColumnCount() {
            return 2;
        }

        @Override
        public int getRowCount() {
            return listData.size();
        }

        @Override
        public String getColumnName(int column) {
            String colName = null;
            switch (column) {
                case 0:
                    colName = "Name";
                    break;
                case 1:
                    colName = "Ingest";
                    break;
                default:
                    ;

            }
            return colName;
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            Object ret = null;
            TableEntry entry = null;
            //iterate until row
            Iterator<TableEntry> it = listData.iterator();
            for (int i = 0; i <= rowIndex; ++i) {
                entry = it.next();
            }
            switch (columnIndex) {
                case 0:
                    ret = (Object) entry.name;
                    break;
                case 1:
                    ret = (Object) entry.useForIngest;
                    break;
                default:
                    break;
            }
            return ret;
        }

        @Override
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            return columnIndex == 1 ? true : false;
        }

        @Override
        public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
            if (columnIndex == 1) {
                TableEntry entry = null;
                //iterate until row
                Iterator<TableEntry> it = listData.iterator();
                for (int i = 0; i <= rowIndex && it.hasNext(); ++i) {
                    entry = it.next();
                }
                if (entry != null){
                    if(columnIndex == 1)
                        entry.useForIngest = (Boolean) aValue;
                }
               
            }
        }

        @Override
        public Class getColumnClass(int c) {
            return getValueAt(0, c).getClass();
        }

        List<String> getAllLists() {
            List<String> ret = new ArrayList<String>();
            for (TableEntry e : listData) {
                ret.add(e.name);
            }
            return ret;
        }
        
        List<String> getIngestLists() {
            List<String> ret = new ArrayList<String>();
            for (TableEntry e : listData) {
                if (e.useForIngest && !e.name.equals("")) {
                    ret.add(e.name);
                }
            }
            return ret;
        }

        List<String> getSelectedLists(int[] selected) {
            List<String> ret = new ArrayList<String>();
            for(int i = 0; i < selected.length; i++){
                ret.add((String) getValueAt(0, selected[i]));
            }
            return ret;
        }

        boolean listExists(String list) {
            List<String> all = getAllLists();
            return all.contains(list);
        }

        //delete selected from handle, events are fired from the handle
        void deleteSelected(int[] selected) {
            List<String> toDel = new ArrayList<String>();
            for(int i = 0; i < selected.length; i++){
                toDel.add((String) getValueAt(0, selected[i]));
            }
            for (String del : toDel) {
                listsHandle.deleteList(del);
            }

        }

        //resync model from handle, then update table
        void resync() {
            listData.clear();
            addLists(listsHandle.getListsL());
            fireTableDataChanged();
        }

        //resync single model entry from handle, then update table
        void resync(String listName) {
            TableEntry found = null;
            for (TableEntry e : listData) {
                if (e.name.equals(listName)) {
                    found = e;
                    break;
                }
            }
            if (found != null) {
                listData.remove(found);
                addList(listsHandle.getList(listName));
            }
            fireTableDataChanged();
        }

        //add list to the model
        private void addList(KeywordSearchList list) {
            if (!listExists(list.getName())) {
                listData.add(new TableEntry(list));
            }
        }

        //add lists to the model
        private void addLists(List<KeywordSearchList> lists) {
            for (KeywordSearchList list : lists) {
                if (!listExists(list.getName())) {
                    listData.add(new TableEntry(list));
                }
            }
        }

        //single model entry
        class TableEntry implements Comparable {

            String name;
            Boolean useForIngest;

            TableEntry(KeywordSearchList list, Boolean useForIngest) {
                this.name = list.getName();
                this.useForIngest = useForIngest;
            }

            TableEntry(KeywordSearchList list) {
                this.name = list.getName();
                this.useForIngest = false;
            }

            @Override
            public int compareTo(Object o) {
                return this.name.compareTo(((TableEntry) o).name);
            }
        }
    }

    /**
     * tooltips that show text
     */
    private static class CellTooltipRenderer extends DefaultTableCellRenderer {

        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value,
                boolean isSelected, boolean hasFocus,
                int row, int column) {

            if (column < 3) {
                String val = (String) table.getModel().getValueAt(row, column);
                setToolTipText(val);
                setText(val);
            }

            return this;
        }
    }
    
    void addListSelectionListener(ListSelectionListener l) {
        listsTable.getSelectionModel().addListSelectionListener(l);
    }
    
    List<String> getAllLists() {
        return tableModel.getAllLists();
    }
    
    List<String> getIngestLists() {
        return tableModel.getIngestLists();
    }
}
